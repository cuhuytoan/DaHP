# Deployment Rules for CMS Migration
# Reference: docs/migration-plan.md

## Overview
This file defines deployment rules for the CMS migration project,
ensuring reliable and secure deployment across development, staging, and production environments.

## Environment Strategy

### Environment Types
- **Development**: Local development and feature testing
- **Staging**: Pre-production testing and validation
- **Production**: Live system serving end users

### Environment Configuration
```yaml
# environments.yaml
environments:
  development:
    api_url: "http://localhost:5000"
    frontend_url: "http://localhost:3000"
    database: "cms_dev"
    redis: "localhost:6379"

  staging:
    api_url: "https://api-staging.example.com"
    frontend_url: "https://staging.example.com"
    database: "cms_staging"
    redis: "redis-staging:6379"

  production:
    api_url: "https://api.example.com"
    frontend_url: "https://example.com"
    database: "cms_prod"
    redis: "redis-prod:6379"
```

---

## Infrastructure Requirements

### API Server Requirements
```yaml
# docker-compose.yml (API)
version: '3.8'
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile.api
    ports:
      - "5000:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ConnectionStrings__CmsConnection=${DATABASE_URL}
      - JWT__Key=${JWT_SECRET}
    depends_on:
      - db
      - redis
    restart: unless-stopped

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=cms_prod
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

### Frontend Deployment
```yaml
# vercel.json (Vercel deployment)
{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/next"
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "${API_URL}/api/$1"
    },
    {
      "src": "/(.*)",
      "dest": "/$1"
    }
  ],
  "env": {
    "NEXT_PUBLIC_API_URL": "@api-url"
  }
}
```

### Database Infrastructure
```sql
-- Production database configuration
-- postgresql.conf optimizations
shared_buffers = 256MB
effective_cache_size = 1GB
maintenance_work_mem = 64MB
checkpoint_completion_target = 0.9
wal_buffers = 16MB
default_statistics_target = 100
random_page_cost = 1.1
effective_io_concurrency = 200
work_mem = 4MB
min_wal_size = 1GB
max_wal_size = 4GB
max_worker_processes = 4
max_parallel_workers_per_gather = 2
max_parallel_workers = 4
max_parallel_maintenance_workers = 2
```

---

## Deployment Pipeline

### CI/CD Pipeline Structure
```yaml
# .github/workflows/deploy.yml
name: Deploy to Production
on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run tests
        run: |
          dotnet test
          npm test

  build-api:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build API
        run: |
          dotnet publish -c Release -o ./publish
      - name: Upload API artifact
        uses: actions/upload-artifact@v3
        with:
          name: api-build
          path: ./publish/

  build-frontend:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Frontend
        run: |
          npm ci
          npm run build
      - name: Upload Frontend artifact
        uses: actions/upload-artifact@v3
        with:
          name: frontend-build
          path: ./out/

  deploy-staging:
    needs: [build-api, build-frontend]
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Deploy to staging
        run: |
          # Deploy API
          # Deploy Frontend

  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Deploy to production
        run: |
          # Deploy API
          # Deploy Frontend
          # Run database migrations
          # Update DNS if needed
```

### Blue-Green Deployment Strategy
```bash
# Blue-green deployment script
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Starting blue-green deployment...${NC}"

# Determine current live environment
CURRENT_LIVE=$(kubectl get svc api-service -o jsonpath='{.spec.selector.version}')

if [ "$CURRENT_LIVE" = "blue" ]; then
    NEW_VERSION="green"
    OLD_VERSION="blue"
else
    NEW_VERSION="blue"
    OLD_VERSION="green"
fi

echo -e "${YELLOW}Deploying to $NEW_VERSION environment...${NC}"

# Deploy new version
kubectl set image deployment/api-$NEW_VERSION api=$API_IMAGE:$TAG
kubectl set image deployment/frontend-$NEW_VERSION frontend=$FRONTEND_IMAGE:$TAG

# Wait for deployment to be ready
kubectl rollout status deployment/api-$NEW_VERSION
kubectl rollout status deployment/frontend-$NEW_VERSION

# Run health checks
echo -e "${YELLOW}Running health checks...${NC}"
if curl -f http://api-$NEW_VERSION/api/health; then
    echo -e "${GREEN}Health check passed${NC}"

    # Switch traffic
    kubectl patch svc api-service -p "{\"spec\":{\"selector\":{\"version\":\"$NEW_VERSION\"}}}"
    kubectl patch svc frontend-service -p "{\"spec\":{\"selector\":{\"version\":\"$NEW_VERSION\"}}}"

    echo -e "${GREEN}Traffic switched to $NEW_VERSION${NC}"

    # Scale down old version
    kubectl scale deployment api-$OLD_VERSION --replicas=0
    kubectl scale deployment frontend-$OLD_VERSION --replicas=0

    echo -e "${GREEN}Deployment completed successfully${NC}"
else
    echo -e "${RED}Health check failed. Rolling back...${NC}"

    # Rollback: scale down new version
    kubectl scale deployment api-$NEW_VERSION --replicas=0
    kubectl scale deployment frontend-$NEW_VERSION --replicas=0

    exit 1
fi
```

---

## Database Migration Strategy

### Migration Scripts Organization
```
database/
├── migrations/
│   ├── 001_initial_schema.sql
│   ├── 002_add_indexes.sql
│   ├── 003_migrate_data.sql
│   └── 004_post_migration.sql
├── functions/
│   ├── sp_article_search.sql
│   ├── sp_product_search.sql
│   └── sp_category_tree.sql
├── seeds/
│   ├── article_status.sql
│   ├── product_status.sql
│   └── default_settings.sql
└── rollback/
    ├── rollback_001.sql
    └── rollback_002.sql
```

### Migration Execution
```bash
#!/bin/bash
# migrate.sh

set -e

echo "Starting database migration..."

# Create backup
echo "Creating backup..."
pg_dump -h $DB_HOST -U $DB_USER -d $DB_NAME > backup_$(date +%Y%m%d_%H%M%S).sql

# Run migrations in order
echo "Running schema migrations..."
psql -h $DB_HOST -U $DB_USER -d $DB_NAME -f database/migrations/001_initial_schema.sql
psql -h $DB_HOST -U $DB_USER -d $DB_NAME -f database/migrations/002_add_indexes.sql

# Run data migration
echo "Running data migration..."
python3 database/migrate_data.py

# Run post-migration scripts
echo "Running post-migration scripts..."
psql -h $DB_HOST -U $DB_USER -d $DB_NAME -f database/migrations/004_post_migration.sql

# Seed initial data
echo "Seeding initial data..."
psql -h $DB_HOST -U $DB_USER -d $DB_NAME -f database/seeds/article_status.sql
psql -h $DB_HOST -U $DB_USER -d $DB_NAME -f database/seeds/product_status.sql

# Create functions
echo "Creating database functions..."
psql -h $DB_HOST -U $DB_USER -d $DB_NAME -f database/functions/sp_article_search.sql
psql -h $DB_HOST -U $DB_USER -d $DB_NAME -f database/functions/sp_product_search.sql

# Validate migration
echo "Validating migration..."
python3 database/validate_migration.py

echo "Migration completed successfully!"
```

### Rollback Procedures
```bash
#!/bin/bash
# rollback.sh

echo "Starting rollback procedure..."

# Confirm rollback
read -p "Are you sure you want to rollback? This will restore the backup. (y/N): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    exit 1
fi

# Stop application
echo "Stopping application..."
kubectl scale deployment api --replicas=0
kubectl scale deployment frontend --replicas=0

# Restore database
echo "Restoring database from backup..."
LATEST_BACKUP=$(ls -t backup_*.sql | head -1)
psql -h $DB_HOST -U $DB_USER -d $DB_NAME < $LATEST_BACKUP

# Restart application
echo "Restarting application..."
kubectl scale deployment api --replicas=3
kubectl scale deployment frontend --replicas=3

echo "Rollback completed."
```

---

## Monitoring and Observability

### Application Monitoring
```yaml
# monitoring.yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    scrape_configs:
      - job_name: 'api'
        static_configs:
          - targets: ['api:5000']
      - job_name: 'frontend'
        static_configs:
          - targets: ['frontend:3000']
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - name: prometheus
        image: prom/prometheus
        ports:
        - containerPort: 9090
        volumeMounts:
        - name: config
          mountPath: /etc/prometheus
      volumes:
      - name: config
        configMap:
          name: prometheus-config
```

### Logging Configuration
```csharp
// Program.cs - Serilog configuration
builder.Host.UseSerilog((context, services, configuration) => configuration
    .ReadFrom.Configuration(context.Configuration)
    .ReadFrom.Services(services)
    .Enrich.FromLogContext()
    .Enrich.WithMachineName()
    .Enrich.WithEnvironmentName()
    .Enrich.WithProperty("Application", "CMS.API")
    .WriteTo.Console()
    .WriteTo.Elasticsearch(new ElasticsearchSinkOptions(new Uri("http://elasticsearch:9200"))
    {
        IndexFormat = "cms-api-{0:yyyy.MM.dd}",
        AutoRegisterTemplate = true,
        NumberOfReplicas = 1,
        NumberOfShards = 2
    })
    .WriteTo.Seq("http://seq:5341"));
```

### Health Checks
```csharp
// Health checks configuration
builder.Services.AddHealthChecks()
    .AddNpgSql(builder.Configuration.GetConnectionString("CmsConnection")!)
    .AddRedis(builder.Configuration["Redis:ConnectionString"]!)
    .AddUrlGroup(new Uri($"{builder.Configuration["Frontend:Url"]}/health"), "Frontend");

app.MapHealthChecks("/health");
app.MapHealthChecks("/health/ready", new HealthCheckOptions
{
    Predicate = healthCheck => healthCheck.Tags.Contains("ready")
});
app.MapHealthChecks("/health/live", new HealthCheckOptions
{
    Predicate = _ => false
});
```

---

## Security Configuration

### SSL/TLS Configuration
```nginx
# nginx.conf
server {
    listen 443 ssl http2;
    server_name api.example.com;

    ssl_certificate /etc/ssl/certs/api.example.com.crt;
    ssl_certificate_key /etc/ssl/private/api.example.com.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;

    location / {
        proxy_pass http://api:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### Secrets Management
```yaml
# secrets.yml
apiVersion: v1
kind: Secret
metadata:
  name: cms-secrets
type: Opaque
data:
  database-password: <base64-encoded-password>
  jwt-secret: <base64-encoded-secret>
  redis-password: <base64-encoded-password>
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  template:
    spec:
      containers:
      - name: api
        env:
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: cms-secrets
              key: database-password
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: cms-secrets
              key: jwt-secret
```

### Network Security
```yaml
# network-policy.yml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-network-policy
spec:
  podSelector:
    matchLabels:
      app: api
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 5000
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: db
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
```

---

## Backup and Recovery

### Automated Backups
```bash
#!/bin/bash
# backup.sh

BACKUP_DIR="/backups"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_NAME="cms_backup_$DATE"

echo "Starting backup: $BACKUP_NAME"

# Database backup
pg_dump -h $DB_HOST -U $DB_USER -d $DB_NAME -F c -f $BACKUP_DIR/$BACKUP_NAME.sql

# File system backup (if needed)
# tar -czf $BACKUP_DIR/files_$BACKUP_NAME.tar.gz /app/uploads

# Upload to cloud storage
aws s3 cp $BACKUP_DIR/$BACKUP_NAME.sql s3://cms-backups/database/
aws s3 cp $BACKUP_DIR/files_$BACKUP_NAME.tar.gz s3://cms-backups/files/

# Clean up old backups (keep last 30 days)
find $BACKUP_DIR -name "cms_backup_*.sql" -mtime +30 -delete
find $BACKUP_DIR -name "files_*.tar.gz" -mtime +30 -delete

echo "Backup completed: $BACKUP_NAME"
```

### Disaster Recovery Plan
```yaml
# disaster-recovery.yml
# Steps to execute in case of disaster:
# 1. Assess the damage and determine recovery scope
# 2. Restore from latest backup
# 3. Verify data integrity
# 4. Update DNS if needed
# 5. Notify stakeholders
# 6. Monitor system closely for 24-48 hours

recovery_procedures:
  database_failure:
    - Identify the cause of failure
    - Restore from latest automated backup
    - Run integrity checks
    - Update application connections
    - Monitor performance

  application_failure:
    - Check container health
    - Restart failed services
    - Check logs for errors
    - Scale services if needed
    - Implement circuit breaker if necessary

  infrastructure_failure:
    - Switch to backup region (if multi-region)
    - Scale up remaining instances
    - Implement emergency maintenance page
    - Communicate with users
```

---

## Performance Optimization

### CDN Configuration
```javascript
// next.config.js - CDN optimization
module.exports = {
  images: {
    domains: ['cdn.example.com'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: `${process.env.API_URL}/api/:path*`,
      },
    ];
  },
};
```

### Caching Strategy
```csharp
// Redis caching configuration
builder.Services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = builder.Configuration.GetConnectionString("Redis");
});

builder.Services.AddOutputCache(options =>
{
    options.AddBasePolicy(builder =>
        builder.Expire(TimeSpan.FromMinutes(10)));
    options.AddPolicy("Articles", builder =>
        builder.Expire(TimeSpan.FromMinutes(5))
               .SetVaryByQuery("page", "category"));
});
```

---

## Deployment Checklist

### Pre-Deployment
- [ ] All tests pass
- [ ] Security scan completed
- [ ] Performance benchmarks met
- [ ] Database backup created
- [ ] Rollback plan documented
- [ ] Team notified of deployment

### Deployment Steps
- [ ] Deploy to staging environment
- [ ] Run integration tests
- [ ] Perform user acceptance testing
- [ ] Deploy to production
- [ ] Update DNS if needed
- [ ] Monitor system health
- [ ] Notify stakeholders

### Post-Deployment
- [ ] Validate all endpoints work
- [ ] Check database connections
- [ ] Verify file uploads work
- [ ] Test user authentication
- [ ] Monitor error rates
- [ ] Create incident response plan